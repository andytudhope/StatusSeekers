const assertRevert = require('./helpers/assertRevert')
const BigNumber = web3.BigNumber
const {
  computeSignature
} = require('../backend/tokenIssue.js')
const NonFungibleToken = artifacts.require('NonFungibleCollectable.sol')

require('chai')
  .use(require('chai-as-promised'))
  .use(require('chai-bignumber')(BigNumber))
  .should()

contract('NonFungibleToken', accounts => {
  let token = null
  const _name = 'Non Fungible Collectable'
  const _symbol = 'VAT' // Valuable Art Token
  const _firstTokenId = 1
  const _secondTokenId = 2
  const nonFungibleCollectableOwner = accounts[0] // only owner can create new tokens
  const issuingWallet = accounts[1] // only issuing wallet can issue tokens via off chain signature
  const recipientAddress = accounts[2] // only issuing wallet can issue tokens via off chain signature
  const attackerAddress = accounts[3]
  const otherUser = accounts[4]

  beforeEach(async () => {
    token = await NonFungibleToken.new(_name, _symbol, issuingWallet, { from: nonFungibleCollectableOwner })
    await token.ownerMint(issuingWallet, _firstTokenId, { from: nonFungibleCollectableOwner })
    await token.ownerMint(issuingWallet, _secondTokenId, { from: nonFungibleCollectableOwner })
  })

  describe('setup', () => {
    it('should deploy and test tokens correctly issued', async () => {
      const name = await token.name()
      name.should.be.equal(_name)
      const symbol = await token.symbol()
      symbol.should.be.equal(_symbol)
      const totalSupply = await token.totalSupply()
      totalSupply.should.be.bignumber.equal(2)
      const balance1 = await token.balanceOf(issuingWallet)
      balance1.should.be.bignumber.equal(2)
      const balance2 = await token.balanceOf(attackerAddress)
      balance2.should.be.bignumber.equal(0)
    })
  })

  describe('issuing signature validation', () => {
    let signatureObject
    let solHashResult
    beforeEach(async () => {
      signatureObject = computeSignature(_firstTokenId, recipientAddress, issuingWallet, web3)
      solHashResult = await token.hasher(_firstTokenId, {from: recipientAddress})
    })

    it('should hash the user address and tokenId the same in javascript as in solidity', async () => {
      signatureObject.prefixedHash.should.be.equal(solHashResult)
    })

    describe('the getAddress function', () => {
      it('should get the correct address', async () => {
        const {prefixedHash, v, r, s} = signatureObject
        const address = await token.getAddress(prefixedHash, v, r, s)
        address.should.be.equal(issuingWallet)
      })
    })

    it('should allow the user to claim a token from the `collectableCouponIssuer` if signature is correct', async () => {
      const {prefixedHash, v, r, s} = signatureObject
      const issueTx = await token.claimCollectableWithCoupon(_firstTokenId, prefixedHash, v, r, s, {from: recipientAddress})
      const newOwner = await token.ownerOf(_firstTokenId)
      newOwner.should.be.equal(recipientAddress)
    })

    describe('when the user tries to use someone elses coupon/signature', () => {
      it('reverts', async () => {
        const {prefixedHash, v, r, s} = signatureObject
        await assertRevert(token.claimCollectableWithCoupon(_firstTokenId, prefixedHash, v, r, s, {from: attackerAddress}))
        const newOwner = await token.ownerOf(_firstTokenId)
        newOwner.should.be.equal(issuingWallet)
        const balance2 = await token.balanceOf(attackerAddress)
        balance2.should.be.bignumber.equal(0)
      })
    })

    describe('when the user tries to claim a token that was not assigned to them via a valid coupon', () => {
      it('reverts', async () => {
        const {prefixedHash, v, r, s} = signatureObject
        await assertRevert(token.claimCollectableWithCoupon(_secondTokenId, prefixedHash, v, r, s, {from: recipientAddress}))
        // neither the token from the signature nor the token in claim move
        const newOwnerT1 = await token.ownerOf(_firstTokenId)
        const newOwnerT2 = await token.ownerOf(_secondTokenId)
        newOwnerT1.should.be.equal(newOwnerT2).be.equal(issuingWallet)
        const balance2 = await token.balanceOf(attackerAddress)
        balance2.should.be.bignumber.equal(0)
      })
    })

    describe('when the attacker tries to use a signature generated by a party other than the `collectableCouponIssuer`', () => {
      it('reverts', async () => {
        const {prefixedHash, v, r, s} = computeSignature(_firstTokenId, recipientAddress, attackerAddress, web3)
        await assertRevert(token.claimCollectableWithCoupon(_firstTokenId, prefixedHash, v, r, s, {from: recipientAddress}))
        const newOwner = await token.ownerOf(_firstTokenId)
        newOwner.should.be.equal(issuingWallet)
        const balance2 = await token.balanceOf(attackerAddress)
        balance2.should.be.bignumber.equal(0)
      })
    })

    describe('when the attacker tries to claim a token not owned by `collectableCouponIssuer`', () => {
      it('reverts', async () => {
        await token.transfer(otherUser, _firstTokenId, { from: issuingWallet });
        const newOwner = await token.ownerOf(_firstTokenId)
        newOwner.should.be.equal(otherUser)

        const {prefixedHash, v, r, s} = signatureObject
        await assertRevert(token.claimCollectableWithCoupon(_firstTokenId, prefixedHash, v, r, s, {from: recipientAddress}))
        const balance2 = await token.balanceOf(attackerAddress)
        balance2.should.be.bignumber.equal(0)
      })
    })
  })
})
