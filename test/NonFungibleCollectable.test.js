const abi = require('ethereumjs-abi')
const assertRevert = require('./helpers/assertRevert')
const BigNumber = web3.BigNumber
const {
  computeSignature
} = require('../backend/tokenIssue.js')
const NonFungibleToken = artifacts.require('NonFungibleCollectable.sol')

require('chai')
  .use(require('chai-as-promised'))
  .use(require('chai-bignumber')(BigNumber))
  .should()

contract('NonFungibleToken', accounts => {
  let token = null
  const _name = 'Non Fungible Collectable'
  const _symbol = 'VAT' // Valuable Art Token
  const _firstTokenId = 1
  const _secondTokenId = 2
  const nonFungibleCollectableOwner = accounts[0] // only owner can create new tokens
  const issuingWallet = accounts[1] // only issuing wallet can issue tokens via off chain signature
  const recipientAddress = accounts[2] // only issuing wallet can issue tokens via off chain signature
  const attackerAddress = accounts[3]

  beforeEach(async () => {
    token = await NonFungibleToken.new(_name, _symbol, issuingWallet, { from: nonFungibleCollectableOwner })
    await token.ownerMint(issuingWallet, _firstTokenId, { from: nonFungibleCollectableOwner })
    await token.ownerMint(issuingWallet, _secondTokenId, { from: nonFungibleCollectableOwner })
  })

  describe('setup', () => {
    it('should deploy and test tokens correctly issued', async () => {
      const name = await token.name()
      name.should.be.equal(_name)
      const symbol = await token.symbol()
      symbol.should.be.equal(_symbol)
      const totalSupply = await token.totalSupply()
      totalSupply.should.be.bignumber.equal(2)
      const balance1 = await token.balanceOf(issuingWallet)
      balance1.should.be.bignumber.equal(2)
      const balance2 = await token.balanceOf(attackerAddress)
      balance2.should.be.bignumber.equal(0)
    })
  })

  describe('issuing signature validation', () => {
    let signatureObject
    let solHashResult
    beforeEach(async () => {
      signatureObject = computeSignature(_firstTokenId, recipientAddress, issuingWallet, web3)
      solHashResult = await token.hasher(_firstTokenId, {from: recipientAddress})
    })

    it('should hash the user address and tokenId the same in javascript as in solidity', async () => {
      signatureObject.hash.should.be.equal(solHashResult)
    })

    it('user should be able to claim an a token from the collectableCouponIssuer if signature is correct', async () => {
      const {hash, v, r, s} = signatureObject
      const issueTx = await token.claimCollectableWithCoupon(_firstTokenId, hash, v, r, s, {from: recipientAddress})
      const newOwner = await token.ownerOf(_firstTokenId)
      newOwner.should.be.equal(recipientAddress)
    })

    describe('when the user tries to use someone elses coupon/signature', () => {
      it('reverts', async () => {
        const {hash, v, r, s} = signatureObject
        await assertRevert(token.claimCollectableWithCoupon(_firstTokenId, hash, v, r, s, {from: attackerAddress}))
        const newOwner = await token.ownerOf(_firstTokenId)
        newOwner.should.be.equal(issuingWallet)
        const balance2 = await token.balanceOf(attackerAddress)
        balance2.should.be.bignumber.equal(0)
      })
    })

    describe('when the user tries to claim a token that was not assigned to them via a valid coupon', () => {
      it('reverts', async () => {
        const {hash, v, r, s} = signatureObject
        await assertRevert(token.claimCollectableWithCoupon(_secondTokenId, hash, v, r, s, {from: recipientAddress}))
        const newOwner = await token.ownerOf(_firstTokenId)
        newOwner.should.be.equal(issuingWallet)
        const balance2 = await token.balanceOf(attackerAddress)
        balance2.should.be.bignumber.equal(0)
      })
    })

    describe('when the attacker tries to use a signature generated by a party other than the `collectableCouponIssuer`', () => {
      it('reverts', async () => {
        const {hash, v, r, s} = computeSignature(_firstTokenId, recipientAddress, attackerAddress, web3)
        await assertRevert(token.claimCollectableWithCoupon(_firstTokenId, hash, v, r, s, {from: recipientAddress}))
        const newOwner = await token.ownerOf(_firstTokenId)
        newOwner.should.be.equal(issuingWallet)
        const balance2 = await token.balanceOf(attackerAddress)
        balance2.should.be.bignumber.equal(0)
      })
    })

    describe('when the attacker tries to claim a token not owned by `collectableCouponIssuer`', () => {
      it('reverts', async () => {
        await token.transfer(recipientAddress, _firstTokenId, { from: issuingWallet });
        const newOwner = await token.ownerOf(_firstTokenId)
        newOwner.should.be.equal(recipientAddress)

        const {hash, v, r, s} = signatureObject
        await assertRevert(token.claimCollectableWithCoupon(_firstTokenId, hash, v, r, s, {from: recipientAddress}))
        const balance2 = await token.balanceOf(attackerAddress)
        balance2.should.be.bignumber.equal(0)
      })
    })
  })
})
